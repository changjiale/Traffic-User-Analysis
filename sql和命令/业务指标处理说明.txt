PV    
	---访问量
	---一天之内访问网站的次数
	---统计日志的数量就可以得到PV
	---不需要在js当中书写额外的代码进行收集

UV
	---独立访客数
	---一天之内访问网站的人的数量
	---为每一个人加一个唯一的标识uvid（生成长度为20位随机数）
	---将生成的唯一标识uvid存入cookie中保存

	#检查当前客户端cookie中是否保存了用户唯一标识uvid
	if（找不到）{
		生成一个uvid=生成20位的随机数作为当前客户的唯一标识
		uvid保存到浏览器的cookie中
	}else{
		直接使用uvid作为当前的客户的唯一标识
	}
	将这个uvid作为日志的一部分提交给日志服务器

VV
	---会话总数
	---一天之内会话的总数量
	---为每个会话产生一个唯一的编号
	---将生成的唯一编号保存到cookie中，之后这个会话的所有访问都会带着会话编号提交给服务器


	
	#从cookie当中获取会话编号
	if（找不到）{
		生成一个10位的随机数作为会话编号
		将会话编号保存在cookie当中
	}else{

		从cookie当中获取会话编号、到上一次的访问时间、上一次的访问页面总数
		if（当前时间-会话保存的时间>超时时间）{
			虽然有会话编号，但是已经超时
			重新生成会话编号
			重新得到当前时间
			重新生成访问页面的总数
			保存在cookie当中（客户端的内存当中）
		}else{		
			获取到10为的随机编号直接使用
			重新等到当前时间
			访问页面总数+1
		}		
	}
	将该会话编号作为日志的一部分提交到日志服务器中

br
	---跳出率（崩出率）
	---一天之内跳珠的会话总数占总的会话总数的比率
	---总的会话数就是--VV
	---在日志的计算过程中，可以通过会话编号将日志进行分组（是不是就是需要得到sessionid---有没有？？在	   创建会话总数已经上传到了服务器中）因此咱们不需要执行多余的参数

newip
	---新增ip总数
	---一天之内所有的ip在去重之后再历史数据中从未数显过的ip
	---客户端的ip--不要从客户端进行获取（很有可能是内网ip）
	---推荐在服务器端进行获取，在服务器端获取的就有可能是公网ip

	为什么在js中很难获取ip地址：
	在js当中很难获取ip地址，因为为了保证数据的安全性js在客户端是以一个封闭的沙盒来运行的
	
	有可能获取到的ip地址不是想要的ip,为什么？？就是因为内网ip不能准确的获取用户位置，没有意义

newcust
	---新增的独立访客数
	---一天之内所有的客户编号（uvid）去重之后在历史数据中从未出现的uvid
	---不需要在js当中进行额外的js代码的编写

avgtime
	---平均访问时长
	---一天之内所有的会话访问时长的平均值
	---每个会话的访问时间累加求和/会话总数

	如何获取会话总数？？已定义会话编号ssid，代表对应的会话

avgdeep
	---平均访问深度
	---一天之内所有的护花访问深度的平均值

	如何求取会话的访问深度？？根据会话id（ssid）进行分组，当前日志访问的是哪一个页面（url表示当前页面的访问地址）

	将业务指标数据进行拼接上传给日志服务器
		